package com.company;
import java.io.Console;
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int cnt = 0; // определяет количество троек;
        double  d [] = new double[2]; //Здесь хранятся координаты точки d: d_x = d[0]; d_y = d[1];
        double ad;//Коэфициент наклона AD;
        double bc;//Коэфициент наклона BC;
        double ads;//смещение прямой на которой лежит отрезок AD по оси х от начала координат;
        double bcs;//смещение прямой на которой лежит отрезок BC по оси х от начала координат;
        int A = sc.nextInt();
        double x[] = new double[A];// Координтаы_x каждой точки из множества A
        double y[] = new double[A];//Координтаы_y каждой точки из множества A
        for (int i = 0; i < A; i++) {
            x[i] = sc.nextInt();
            y[i]=  sc.nextInt();
        } //Вводим координаты точек из множества A
        d[0] = sc.nextDouble();// вводим координаты d
        d[1] = sc.nextDouble();// Ввели все данные, приступим к основному алгоритму:
        for (int i = 0; i <= A - 3; i++) // A-3 тк ожидаем еще точки b и с. То есть всего А-3 шага;
        {
            for (int j = i+1; j <= A - 1; j++) // Начинаем с i+1 до A-1, то есть всего A-2 шага
            {
                for (int k = j+1; k <= A - 1; k++)//А - 3 шага
                {
                    // По сути в этом цикле перебираются значения (всевозможные) для точек a,b,c. Также, заметим ,что у нас не могут эти точки совпадать.;
                    int m=0;
                    //a[0]=x[i] a[1]=y[i] - то есть координата точки а_х = x[i]; а_y = y[i];
                    //b[0]=x[j] b[1]=y[j] аналогично
                    //c[0]=x[k] c[1]=y[k]
                    //d[0] и  d[1] смотри в var
                    if ((Math.abs(x[i]-d[0])==Math.abs(x[j]-x[k])) && (Math.abs(y[i]-d[1])==Math.abs(y[j]-y[k])))
                    {
                        // Здесь была проверка на равенство проекций AD_x и BC_x, также равенство проекций на _y; Необходимое условие;
                        ad=(y[i]-d[1])/(x[i]-d[0]); // Вычисояем коэфициент наклона отрезка AD;
                        bc=(y[j]-y[k])/(x[j]-x[k]);// аналогично
                        ads=(x[i]*d[1]-y[i]*d[0])/(x[i]-d[0]);// вычисляем смещение прямой на которой лежит отрезок AD по оси х от начала координат;
                        bcs=(x[j]*y[k]-y[j]*x[k])/(x[j]-x[k]);// аналогично
                        if ((ad==bc) && (ads!= bcs)) // сначала проверяем их на параллельность по угловым коэффициентам, а потом на то не лежат ли отрезки на одной прямой
                            m++; // вспомагательный счетчик
                    }
                    if (m==0)
                    {
                        //a[0]=x[j] a[1]=y[j]
                        //b[0]=x[i] b[1]=y[i]
                        //c[0]=x[k] c[1]=y[k]
                        //d[0] и d[1] смотри в var
                        if ((Math.abs(x[j]-d[0])==Math.abs(x[i]-x[k])) && (Math.abs(y[j]-d[1])==Math.abs(y[i]-y[k]))) //для тех же точек из А меняем местами координаты a и b (Так как
                        {
                            ad=(y[j]-d[1])/(x[j]-d[0]);
                            bc=(y[i]-y[k])/(x[i]-x[k]);
                            ads=(x[j]*d[1]-y[j]*d[0])/(x[j]-d[0]);
                            bcs=(x[i]*y[k]-y[i]*x[k])/(x[i]-x[k]);
                            if ((ad==bc) && (ads!= bcs))
                                cnt++;
                        }
                    }
                    else cnt++;
                }
            }
        }//вызываем нашу проверку всего 2 раза, вместо C из 3 по 2 ,так как только 2 точки из 3 образуют сторону, а последняя диагональ. А значит, если AD_1 и AD_2 не подходят, то это в любои случае не параллелограмм.
        if (cnt != 0)
            System.out.print("Количество троек:{"+cnt+"}");
        else if (cnt == 0)
            System.out.print("Троек нет");
    }
}
